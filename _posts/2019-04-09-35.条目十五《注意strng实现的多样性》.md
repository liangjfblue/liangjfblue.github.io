---
layout:     post                  
title:      《Effective STL》         
subtitle:   15《注意strng实现的多样性》
date:       2019-04-09          
author:     Liangjf                  
header-img: img/post-bg-hacker.jpg
catalog: true                      
tags:                       
    - STL
---

# 条目十五《注意strng实现的多样性》

下面以一个打印string空对象的大小切入本条目：
    #include <iostream>
    #include <string>

    using namespace std;

    int main()
    {
        string ss;

        printf("ss size: %ld\n", sizeof(ss));
        return 0;
    }

    ss size: 32

string和char*一样大是常见的，但是string的大小是char*的7倍也是常见的。上面例子是在**环境是 gun c++**下的运行结果，可以看到string的大小是char*的4倍。为什么呢？为了理解这个问题，我们需要看string有哪些实现方式。

## 方式
### 方式一：
>每个string对象包含:
>一个配置器的拷贝
>字符串的大小
>容量
>一个指针(指向包含引用计数(“RefCnt”)和字符串值的动态分配的缓冲区)。

![](https://img2018.cnblogs.com/blog/1209698/201901/1209698-20190112154842210-1507098634.png)



实现一的string大小取决于定义的分配子allocator的大小。使用默认的分配子allocator，sring对象的大小就是char*指针的4倍。就是例子的情况。

### 方式二：
>string的大小等于char*指针的大小。每个string对象只包含一个指向一个数据结构的指针(包括了字符串的大小，容量，引用计数，指向动态分配字符串的缓存的地址的指针，其他的控制并发的参数成员【大小大概是char*指针的6倍】)。

![](https://img2018.cnblogs.com/blog/1209698/201901/1209698-20190112154859280-1692791923.png)

### 方式三：
>string的大小等于char*指针的大小。每个string对象只包含一个指向数据结构的指针(字符串大小，容量，引用计数，值可共享性数据+字符串值)

![](https://img2018.cnblogs.com/blog/1209698/201901/1209698-20190112154925769-750538404.png)

### 方式四：
>string的大小是一个char*指针的7倍。当前string的对象小于15时，直接使用**小字符串优化**，string直接存放字符串对象。当string的对象大于15字节时，缓冲区的第一部分被用作指向一块动态内存的地址的指针。

![](https://img2018.cnblogs.com/blog/1209698/201901/1209698-20190112154941375-2042682988.png)

## 根据使用场景选择string的实现：
- 1.关注动态分配次数，避免选择方式2。方式1和3是1次，方式2是2次(string对象本身，指向的缓冲区)，方式4没有。
- 2.关闭并发。方式3包含了控制并发的参数成员。
- 3.有大量的小字符串。选择方式4.

## 总结一下string的多样性：

- 字符串值可能是或可能不是引用计数的。默认情况下,很多实现的确是用了引用计数,但它们通常提供了关闭的方法，一般是通过预处理器宏。引用计数只对频繁拷贝的字符串有帮助,而有些程序不经常拷贝字符串,所以没有那个开销。

- string对象的大小可能从1到至少7倍char*指针的大小。

- 新字符串值的建立可能需要0、1或2次动态分配。

- string对象可能是或可能不共享字符串的大小和容量信息。

- string可能是或可能不支持每对象配置器。

- 不同实现对于最小化字符缓冲区的配置器有不同策略。
